<!DOCTYPE HTML>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>mvc.js</title>
		
		<link rel="stylesheet" href="css/mvc.css" type="text/css" media="screen" title="no title" charset="utf-8">
	</head>
	<body>
		<a href="http://github.com/rlayte/mvc.js"><img style="position: fixed; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" /></a>
		
		<div class="sidebar">
			<h1>mvc.js</h1>
			<p>Simple, light-weight MVC framework for client-side applications.</p>
			
			<ul>
				<li><a href="#downloads" title="">Downloads</a></li>
				<li><a href="#getting_started" title="">Geting started</a></li>
				<li><a href="http://rlayte.github.com/mvc.js/docs/output/" title="">Documentation</a></li>
				<li><a href="#examples" title="">Examples</a></li>
				<li><a href="#faqs" title="">FAQs</a></li>
			</ul>
		</div>
		
		<div class="content">
			<h2>Framework goals</h2>
			<p>The sole purpose of mvc.js is to provide a way for you to write modular applications - using an implementation of the <a href="http://en.wikipedia.org/wiki/Model%E2%80%93View%E2%80%93Controller">model-view-controler pattern</a> and a <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a> container. There are already many libraries which provide animation, DOM manipulation, and ajax methods (amongst other things) and you are free to use your preferred library in conjunction with mvc.js.</p>

			<p>Due to this single focus, mvc.js is extremely light-weight at just over <strong>1kb when minified and gzipped</strong>.</p>
			
			<hr />
			
			<h2><a href="#downloads" name="downloads">Downloads</a></h2>
			
			<ul>
				<li><a href="http://github.com/rlayte/mvc.js/raw/master/src/mvc.js">Development version</a> (Uncompressed with comments) - <strong>12kb</strong></li>
				<li><a href="http://github.com/rlayte/mvc.js/raw/master/src/mvc.min.js">Production version</a> (Minified without comments) - <strong>1kb when gzipped</strong></li>
			</ul>
			
			<h3>Source code</h3>
			<p>The source code is available for forking on <a href="http://github.com/rlayte/mvc.js">github</a></p>
			
			<h3>Dependencies</h3>
			<p>mvc.js depends on <a href="http://documentcloud.github.com/underscore/">underscore.js</a>, which is an extremely small library (2kb when gzipped) that offers a set of helper methods such as each, map/reduce, clone, etc.</p>
			
			<hr />
			
			<h2><a href="#getting_started" name="getting_started">Getting started</a></h2>
			
			<p>This is a brief guide on how to use the framework. For more information on framework internals take a look at the <a href="http://rlayte.github.com/mvc.js/docs/output/">API reference</a> or the <a href="#examples">example applications</a>.</p>
			
			<h3>Creating an application</h3>

			<p>To create an application with mvc.js you pass a function to the create method that defines the application objects and how they interact together. Within the function you have access to two objects: dispatch and map. Dispatch allows you to send events across the system, see the events documentation for more information. Map provides an API for registering models, views, and controllers. More details on how this is done can be found below.</p>

			<p>Here's a simple example:</p>

			<pre>
mvc.create(function() {

    this.map.model('cart', (function() {

        var current_products;

        return {

            init: function() {
                // set up initial state
            },

            add_product: function(product) {
                // add product to current_products
            }

        }

    }));

    this.map.view($('.items'), {

        init: function() {
            // set up initial view state
        },

        disable: function() {
            // disable items
        }

    });

    this.map.controller('add_product', function(product) {
        // manipulate data and add it to the cart model
    });

    this.dispatch('add_initial_products');

});
			</pre>
			
			<p><em><strong>Note</strong>: you can also map arbitrary values and objects using map.instance and map.singleton. These can be used to map common values (e.g. animation duration) and objects (e.g. product data object).</em></p>

			<h3>Models</h3>

			<p>Models are used to store data, process business logic, and maintain state.</p>

						<p>To create a model in mvc.js you use the map.model method and pass it three parameters: name, model, and optionally dependencies (more on this below). The name parameter is a unique string id used to pull back references to the model. The second argument model is the actual object that is used to represent data.</p>

						<p>This example registers a cart model and defines an API for setting and retrieving it's data.</p>

<pre>
this.map.model('cart', (function() {

    var products = [];

    return {

        add_item: function(item) {
            products.push(item);
        },

        get_item: function(index) {
            return products[index];
        }
    }

}));
</pre>

			<h4>Init method</h4>

			<p>You'll often need to set up initial state when models are registered. To do this you can define an init method on your model object which will be called immediately.</p>

						<p>This example sets the same example as before, but adds a default product to the data store on creation.</p>

<pre>
this.map.model('cart', (function() {

    var products = [];

    return {

        init: function() {
            products.push('Default item');
        },

        add_item: function(item) {
            products.push(item);
        },

        get_item: function(index) {
            return products[index];
        }
    }

}));
</pre>

			<h4>Dispatching events</h4>

			<p>To maintain portability models should know as little about the surrounding system as possible. To achieve this models send events using this.dispatch when data is updated that other objects can react to.</p>

						<p>This example dispatches a product_added event when the product data is updated. Note that the latest item is sent through as a parameter that can then be used by any listening functions.</p>

<pre>
this.map.model('cart', (function() {

    var products = [];

    return {

        add_item: function(item) {
            products.push(item);

            this.dispatch('product_added', [item]);
        }

    }

}));
</pre>			

			<h3>Views</h3>

			<p>Views are representations of the current state held by the application models. The most common representation will be an HTML element (or group of elements), but could also be the url bar, console, etc.</p>

						<p>To register a view in mvc.js you call map.view and pass in the target element and a view object that defines an API for manipulating the element.</p>

<pre>
this.map.view($('.product_list), (function() {

    return {
        display_products: function() {
            $(this.element).show();
        }
    }
});
</pre>			
			
			<p><em><strong>Note</strong>: if an array of view elements is passed in as the first parameter (e.g. using a jQuery selector that selects all elements with a certain class) then a new view object will be created for each element.</em></p>

			<h4>Init method</h4>

			<p>As with models you'll often need to define the initial state of views. This can be achieved in the same way by assigning an init method on your view object.</p>

<pre>
this.map.view($('.product_list), (function() {

    return {
        init: function() {
            $(this.element).hide();
        },

        display_products: function() {
            $(this.element).show();
        }
    }
});
</pre>

			<h4>Handling events</h4>

			<p>Views are less portable than the model layer because they have to react to specific events. To do this they must be able to register event listener, which can be achieved in to ways.</p>

						<p>First, you can manually define event listeners by using the events.listen method, which requires an event type and callback as parameters. For example:</p>

<pre>
this.map.view($('.product_list), (function() {

    var handler = function() {

    }

    return {
        init: function() {
            $(this.element).hide();

            this.events.listen('product_added', handler);
        }
    }
});
</pre>

			<p>Alternatively, you can automatically create listeners by defining public methods on you view object. All methods (apart from init) will be registered as listeners using their name as the event type. For example the following view will react to product_added when dispatched.</p>

<pre>
this.map.view($('.product_list), (function() {

    return {

        init: function() {
            $(this.element).hide();
        },

        product_added: function() {

        }
    }
});
</pre>			
			
			<h4>Dispatching events</h4>

			<p>Views can also dispatch events, generally to call required controllers. This is done by calling events.dispatch with a required event type and optionally any parameters to be used by the callback functions.</p>

<pre>
this.map.view($('.product_list), (function() {

    return {

        init: function() {
            this.dispatch('view_created');
        }

    }
});
</pre>			
			
			<h4>Defining dependencies</h4>

			<p>mvc.js uses a form of dependency injection to define requirements between objects. This is done in views by creating a dependencies property on the view object, which contains an array of string references to registered objects. Each of these dependencies is then added on to the object so the view can interact with it as needed.</p>

						<p>In this example a model is registered which a view then defines as a dependency and directly interacts with.</p>

<pre>
this.map.model('cart', (function() {

    var products = [];

    return {
        add_item: function(item) {
            products.push(item);
        }
    }

}));

this.map.view($('.products'), (function() {

    return {
        dependencies: ['cart'],

        init: function() {
            this.cart.add_item('something');
        }
    }
}));
</pre>			

			<h3>Controllers</h3>

			<p>Controllers are used to pass information between the model and view layers of you applications.</p>

						<p>Controllers are defined in mvc.js by simply registering event listeners</p>.

<pre>
this.map.controller('example', function(item) {
    // logic here
});
</pre>			
			
			<h4>Mapping framework objects</h4>

			<p>The context function that sets up applications is actually a controller and all controllers have access to the same API (i.e. map.model, map.view, dispatch, etc.). This means that controllers allow you to split up complex startup logic into manageable chunks and define new framework objects at run-time.</p>

						<p>For example, this controller will register a new view when called:</p>

<pre>
this.map.controller('add_item', function(item) {
    this.map.view(item, {
        check_stock: function() {}
    });
});
</pre>			

			<h3>Defining dependencies</h3>

			<p>In addition to this standard API you can also define additional dependencies by passing in an array of string IDs as a third parameter.</p>

<pre>
this.map.controller('add_item', function(item) {
    this.cart.add_item(item);
}, ['cart']);
</pre>

			
			<hr />
			
			<h2><a href="#examples" name="examples">Examples</a></h2>
			
			<ul>
				<li><a href="http://rlayte.github.com/mvc.js/examples/hello_world">Hello world</a></li>
				<li><a href="http://rlayte.github.com/mvc.js/examples/shopping_cart">Shopping cart</a></li>
				<li>Twitter client <em>(coming soon)</em></li>
				<li>Carousel <em>(coming soon)</em></li>
				<li>Video player <em>(coming soon)</em></li>
			</ul>
			
			<hr />
			
			<h2><a href="#faqs" name="faqs">FAQs</a></h2>
			<p>Coming soon...</p>
			
		</div>
	</body>
</html>
