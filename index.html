<!DOCTYPE HTML>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>mvc.js</title>
		
		<link rel="stylesheet" href="css/mvc.css" type="text/css" media="screen" title="no title" charset="utf-8">
	</head>
	<body>
		<a href="http://github.com/rlayte/mvc.js"><img style="position: fixed; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" /></a>
		
		<div class="sidebar">
			<h1>mvc.js</h1>
			<p>Simple, light-weight MVC framework for client-side applications.</p>
			
			<ul>
				<li><a href="#downloads" title="">Downloads</a></li>
				<li><a href="#getting_started" title="">Geting started</a></li>
				<li><a href="http://rlayte.github.com/mvc.js/docs/output/" title="">Documentation</a></li>
				<li><a href="#examples" title="">Examples</a></li>
				<li><a href="#faqs" title="">FAQs</a></li>
			</ul>
		</div>
		
		<div class="content">
			<h2>Framework goals</h2>
			<p>The sole purpose of mvc.js is to provide a way for you to write modular applications - using an implementation of the <a href="http://en.wikipedia.org/wiki/Model%E2%80%93View%E2%80%93Controller">model-view-controler pattern</a> and a <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a> container. There are already many libraries which provide animation, DOM manipulation, and ajax methods (amongst other things) and you are free to use your preferred library in conjunction with mvc.js.</p>

			<p>Due to this single focus, mvc.js is extremely light-weight at just over <strong>1kb when minified and gzipped</strong>.</p>
			
			<hr />
			
			<h2><a href="#downloads" name="downloads">Downloads</a></h2>
			
			<ul>
				<li><a href="http://github.com/rlayte/mvc.js/raw/master/src/mvc.js">Development version</a> (Uncompressed with comments) - <strong>12kb</strong></li>
				<li><a href="http://github.com/rlayte/mvc.js/raw/master/src/mvc.min.js">Production version</a> (Minified without comments) - <strong>1kb when gzipped</strong></li>
			</ul>
			
			<p>The source code is available for forking on <a href="http://github.com/rlayte/mvc.js">github</a></p>
			
			<h3>Dependencies</h3>
			<p>mvc.js depends on <a href="http://documentcloud.github.com/underscore/">underscore.js</a>, which is an extremely small library (2kb when gzipped) that offers a set of helper methods such as each, map/reduce, clone, etc.</p>
			
			<hr />
			
			<h2><a href="#getting_started" name="getting_started">Getting started</a></h2>
			
			<p>This is a brief guide on how to use the framework. For more information on framework internals take a look at the <a href="http://rlayte.github.com/mvc.js/docs/output/">API reference</a> or the <a href="#examples">example applications</a>.</p>

            <h3>Creating an application</h3>
                <p>To create an application with mvc.js you pass an object that defines the models, views, and controllers (see below for details on how this works).</p>
                <p>Here's a simple example:</p>
<pre>
mvc.create({
    models: {

        cart: {
            facade: {
                init: function() {
                    // set up initial state
                },

                add_product: function(product) {
                    // add product to current_products
                }
            }

        }

    },

    views: {

        items: {

            element: $('.items'),
            requires: ['cart'],
            mediator: { 
                init: function() {
                    this.cart.add_products();
                },

                disable: function() {
                    $(this.element).find('.items').hide();
                }
            }

        }

    },

    controllers: {

        setup_items: {
            requires: ['cart'],
            command: function() {
                this.cart.add_product();
            }
        }            
    }

});
</pre>

                <h3>Models</h3>

                <p>Models are used to store data, process business logic, and maintain state.</p>

                <p>To create models in mvc.js you define a collection of models in the config object passed to the create function. Each model is registered as a dependency based on it's key and should have define a facade, which defines a public API.</p>

                <p>This example registers a cart model and defines an API for setting and retrieving it's data.</p>

<pre>
mvc({

    models: {

        cart: {
            facade: (function(){

                var products = [];

                return {

                    add_item: function(item) {
                        products.push(item);
                    },

                    get_item: function(index) {
                        return products[index];
                    }

                }

            })()
        }

    }

});
</pre>

                <h4>Init method</h4>

                <p>You'll often need to set up initial state when models are registered. To do this you can define an init method on your model object which will be called immediately.</p>

                <p>This example sets the same example as before, but adds a default product to the data store on creation.</p>

<pre>
mvc({

    models: {

        cart: {
            facade: (function(){

                var products = [];

                return {

                    init: function() {
                        products.push('Some item');
                    },

                    add_item: function(item) {
                        products.push(item);
                    },

                    get_item: function(index) {
                        return products[index];
                    }

                }

            })()
        }

    }

});
</pre>

                <h4>Dispatching events</h4>

                <p>To maintain portability models should know as little about the surrounding system as possible. To achieve this models send events using this.dispatch when data is updated that other objects can react to.</p>

                <p>This example dispatches a product_added event when the product data is updated. Note that the latest item is sent through as a parameter that can then be used by any listening functions.</p>

<pre>
mvc({

    models: {

        cart: {
            facade: (function(){

                var products = [];

                return {

                    add_item: function(item) {
                        products.push(item);
                        this.dispatch('product_added', [item]);
                    },

                }

            })()
        }

    }

});
</pre>

                <h3>Views</h3>

                <p>Views are representations of the current state held by the application models. The most common representation will be an HTML element (or group of elements), but could also be the url bar, console, etc.<p>

                        <p>To register a view in mvc.js you call the create method with a collection of views, each defines a mediator object which define a public API. Optionally a view element and external dependencies can be defined.<p>
                                
<pre>
mvc({

    views: {

        'items': {

            element: $('.items'),
            mediator: {

                display_products: function() {

                    $(this.element).show();

                }
            }
        }

    }

});
</pre>

                        <h4>Init method</h4>

                        <p>As with models you'll often need to define the initial state of views. This can be achieved in the same way by assigning an init method on your mediator object.</p>

<pre>
mvc({

    views: {

        'items': {

            element: $('.items'),
            mediator: {

                init: function() {
                    // set up initial state
                }

                display_products: function() {

                    $(this.element).show();

                }
            }
        }

    }

});
</pre>

                        <h4>Handling events</h4>

                        <p>Views are less portable than the model layer because they have to react to specific events. To do this they must be able to register event listener, which can be achieved in to ways.</p>

                        <p>First, you can manually define event listeners by using the listen method, which requires an event type and callback as parameters. For example:</p>

<pre>
mvc({

    views: {

        'items': {

            element: $('.items'),
            mediator: (function() {

                var handler = function() {
                    $(this.element).show();
                }

                return {
                    init: function() {
                        $(this.element).hide();

                        this.listen('product_added', handler);
                    }

                }

            })()
        }

    }

});
</pre>
                        
                        <p>Alternatively, you can automatically create listeners by defining public methods on your mediator object. All methods (apart from init) will be registered as listeners using their name as the event type. For example the following view will react to product_added when dispatched.</p>

<pre>
mvc({

    views: {

        'items': {

            element: $('.items'),
            mediator: (function() {

                return {
                    init: function() {
                        $(this.element).hide();
                    },

                    product_added: function() {
                        $(this.element).show();
                    }

                }

            })()
        }
    }
});
</pre>
                        <h4>Dispatching events</h4>
                        <p>Views can also dispatch events, generally to call required controllers. This is done by calling events.dispatch with a required event type and optionally any parameters to be used by the callback functions.</p>

<pre>
mvc({

    views: {

        'items': {

            element: $('.items'),
            mediator: (function() {

                return {
                    init: function() {
                        this.dispatch('add_products');
                    }
                }

            })()
        }

    }

});
</pre>
                        <h4>Defining dependencies</h4>
                        <p>mvc.js uses a form of dependency injection to define requirements between objects. This is done in views by creating a requirements property on the view object, which contains an array of string references to registered objects. Each of these dependencies is then added on to the mediator object so the you can interact with it as needed.</p>
                        <p>In this example a model is registered which a view then defines as a dependency and directly interacts with.</p>
<pre>
mvc({

    models: {

        cart: {
            facade: {
                add_item: function() {}
            }
        }

    },

    views: {

       'items': {

           element: $('.items'),
            requires: ['cart'],
            mediator: (function() {
                return {
                    init: function() {
                        this.cart.add_item('some product');
                    }
                }
            })()

        }

    }

});
</pre>
                        <h3>Controllers</h3>
                        <p>Controllers are used to pass information between the model and view layers of you applications.</p>
                        <p>Controllers are defined in mvc.js by passing a collection of controllers, which define a command function and optionally any required dependencies. The commands are simply registered as event listeners using the object key as the event string.</p>
<pre>
mvc({

    controllers: {

        'remove_all_products': {
            command: function() {}
        }

    }

});
</pre>
                        <h4>Defining dependencies</h4>
                        <p>You can additionally define dependencies by passing in an array of string IDs as the requires property of the controller.</p>
<pre>
mvc({
    controllers: {
        'remove_all_products': {
            requires: ['cart']
            command: function() {
                this.cart.remove_product();
            }
        }
    }
});	
</pre>
                        
                        <h3>Values</h3>

                        <p>You can also map simple values as dependencies, which can be used to alter the behaviour of models, views, and controllers. For example, if a shipping charge needs to be added to orders you could define it in the following way.</p>

<pre>
mvc({

    values: {
        shipping: 5
    },

    models: {
        cart: {
            requires: ['shipping'],
            facade: (function(){

                var total = 0,
                    sub_total = 0;

                return {
                    add_item: function(item) {
                        sub_total += item.price;
                        total = sub_total + this.shipping;
                    }
                };

            })
        }
    }

});
</pre>

                        <p>The advantage of this is that it provides a simple way to configure applications without making changes to the internal code.</p>

                        <h3>Exports</h3>

                        <p>At times it may be neccesary for other applications or arbitrary scripts to interact with your application. This is acheived by defining an exports object which returns a public API to the calling object. For example:</p>

<pre>
var store = mvc({

    ...

    exports: {

        add_product: function() {}
        remove_product: function() {}

    }

});

store.add_product('t shirt');
</pre>

                        <p>To keep your application encapsulated the external functions cannot directly access models or views, but are able to dispatch and listen for events. To make a change within the system you can dispatch an event which will trigger an internal listener to carry out the required task.</p>

<pre>
var store = mvc({

    models {

        cart: {
            facade: {
                add_item: function() {}
            }
        }

    },

    controllers: {

        add_product: {
            requires: ['cart'],
            command: function(product) {
                this.cart.add_item(product);
            }
        }

    }, 

    exports: {

        add_product: function() {
            this.dispatch('add_product');
        }

    }

});

store.add_product('t shirt');
</pre>

                        <p>Export functions also have access to events.listen and can therefore define external event listeners. For example, if you want to update something outside of the application everytime a product is successfully added to the cart you could do the following:</p>

<pre>
var store = mvc({

    models {

        cart: {
            facade: {
                add_item: function() {
                    this.dispatch('product_added');
                }
            }
        }

    },

    exports: {

        on_product_added: function(callback) {
            this.listen('product_added', callback);
        }

    }

});

store.on_product_added(function() {
    $('.something').show();
});
</pre>

                        <h3>Imports - creating modular applications</h3>

                        <p>It is also possible to import applications into other applications by defining an `imports` object when the mvc function is called. This allows you to build modular, fully-formed apps that can then be plugged together as required. For example, in the above shopping cart code could be broken down into a `cart` app and an `item_list` app, which are then pulled together by a `store` app. The advantage of this is that as long as the API remains consistent the `cart` application could be replaced or reused somewhere else without out affecting any other parts of the sytem. It also allows for these parts of a larger application to be developed completely idependently - as long as an API is agreed upon the modules can be plugged together without a problem.</p>

                        <p>Consider this example:</p>

<pre>
var cart = mvc({
    
    models: {
        ...
    },

    views: {
        ...
    },

    controllers: {
        ...
    },

    exports: {
        add_item: function(item) {
            this.dispatch('add', [item]);
        },

        remove_item: function(item) {
            this.dispatch('remove', [item]);
        }
    }
});
</pre>

                        <p>This is a full application, but instead of using it by itself we are going to implemented it as a component of a larger app. See above for examples on how the models, views, and controllers for this example could be implemented.</p>

                        <p>The important point is the exports API because that defines how other applications can interact with it. The `cart` application defines two methods that can add and remove products from the cart's model.</p>

<pre>
var item_list = mvc({
    
    models: {
        ...
    },

    views: {
        ...
    },

    controllers: {
        ...
    },

    exports: {
        on_select: function(callback) {
            this.listen('item_selected', callback);
        }
    }
});
</pre>

                        <p>Again this is a full application. The exported API for `item_list` defines a method that acts as an event listener for products being added. For example, when a product image is clicked an event will be dispatched which will then call this method.</p>

<pre>
var store = mvc({

    imports: {
        'cart': cart',
        'items': item_list
    },
    
    models: {
        ...
    },

    views: {

        products: {
            requires: ['items', 'cart'],
            mediator: {
                init: function() {
                    var that = this;

                    this.items.on_select(function(item) {
                        that.cart.add_item(item);
                    });
                }
            }
        }

    },

    controllers: {
        ...
    }

});
</pre>

                        <p>This final applications brings the previous two together and links selections made in `item_list` to the `add_item` method of `cart`.</p>

                        <p>In this trivial example it may not be clear why you would want to break applications down into speperate modules. However, as projects grow having the ability to work on different areas seperately allows for better workflow between developers, an easier mechanism for replacing components, and more realistic code reuse.</p>
			
			<hr />
			
			<h2><a href="#examples" name="examples">Examples</a></h2>
			
			<ul>
				<li><a href="http://rlayte.github.com/mvc.js/examples/hello_world">Hello world</a></li>
				<li><a href="http://rlayte.github.com/mvc.js/examples/shopping_cart">Shopping cart</a></li>
				<li><a href="http://rlayte.github.com/mvc.js/examples/carousel">Carousel</a></li>
				<li>Twitter client <em>(coming soon)</em></li>
				<li>Video player <em>(coming soon)</em></li>
			</ul>
			
			<hr />
			
			<h2><a href="#faqs" name="faqs">FAQs</a></h2>
			<p>Coming soon...</p>
			
		</div>
	</body>
</html>
